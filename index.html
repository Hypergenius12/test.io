<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cosmic Bullet Hell – Ultimate Boss Challenge</title>
  <style>
    /* Global Styles */
    html, body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(ellipse at center, #001, #000);
      user-select: none;
      font-family: 'Orbitron', sans-serif;
    }
    /* Cursor visibility based on game state */
    canvas {
      display: block;
      image-rendering: pixelated;
    }
    body.menu-active canvas {
      cursor: default;
    }
    body.playing canvas {
      cursor: none;
    }
    
    /* Menu Overlay */
    #menu {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,40,0.95);
      color: #fff;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10;
      text-shadow: 0 0 10px rgba(0,0,0,0.8);
      padding: 10px;
      box-sizing: border-box;
    }
    #menu h1 {
      font-size: 3em;
      margin-bottom: 15px;
      text-align: center;
    }
    #menu p {
      margin-bottom: 20px;
      text-align: center;
    }
    #boss-select, #all-bosses-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
      width: 90%;
      max-width: 800px;
      margin-bottom: 20px;
    }
    #boss-select button {
      background: linear-gradient(145deg, #444, #222);
      border: 2px solid #666;
      border-radius: 8px;
      color: #fff;
      padding: 10px;
      font-size: 0.9em;
      display: flex;
      flex-direction: column;
      align-items: center;
      word-wrap: break-word;
      box-shadow: 3px 3px 8px #000;
      transition: all 0.25s ease;
      cursor: pointer;
    }
    #boss-select button:hover {
      background: linear-gradient(145deg, #555, #333);
      transform: scale(1.05);
    }
    #boss-select .boss-name {
      font-weight: bold;
    }
    #boss-select .boss-desc {
      font-size: 0.7em;
      color: #ccc;
      margin-top: 5px;
      text-align: center;
    }
    #all-bosses-container button, #retry {
      background: linear-gradient(145deg, #444, #222);
      border: 2px solid #666;
      border-radius: 8px;
      color: #fff;
      padding: 10px;
      font-size: 1em;
      box-shadow: 3px 3px 8px #000;
      transition: all 0.25s ease;
      cursor: pointer;
    }
    #all-bosses-container button:hover, #retry:hover {
      background: linear-gradient(145deg, #555, #333);
      transform: scale(1.05);
    }
    #retry {
      margin-top: 20px;
    }
    #menu p:last-of-type {
      font-size: 0.9em;
    }
    @media (max-width: 600px) {
      #boss-select button {
        font-size: 0.75em;
        padding: 5px;
      }
    }
    
    /* Ship Selection Menu */
    #ship-menu {
      position: absolute;
      top: 10%;
      right: 0;
      width: 300px;
      height: 90%;
      background: rgba(0,0,40,0.98);
      color: #fff;
      display: none;
      flex-direction: column;
      align-items: center;
      z-index: 20;
      overflow-y: auto;
      padding: 20px;
      box-sizing: border-box;
    }
    #ship-menu h2 {
      margin-bottom: 15px;
    }
    #ship-list {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      width: 100%;
    }
    #ship-list button {
      background: linear-gradient(145deg, #444, #222);
      border: 2px solid #666;
      border-radius: 8px;
      color: #fff;
      padding: 10px;
      font-size: 0.9em;
      box-shadow: 3px 3px 8px #000;
      transition: all 0.25s ease;
      cursor: pointer;
    }
    #ship-list button:hover {
      background: linear-gradient(145deg, #555, #333);
      transform: scale(1.05);
    }
    #close-ship-menu {
      margin-top: 20px;
      background: #f55;
    }
  </style>
</head>
<body class="menu-active">
  <!-- Menu Overlay -->
  <div id="menu">
    <h1>Cosmic Boss Fights</h1>
    <p>Select a Boss to Challenge</p>
    <div id="boss-select">
      <!-- Each boss button includes a short description -->
      <button data-boss="0" data-desc="Large, slow bullets in a 30° splash">
        <span class="boss-name">Magma Maw</span>
        <span class="boss-desc">Large, slow bullets</span>
      </button>
      <button data-boss="1" data-desc="Star bullets explode into huge slowing blasts">
        <span class="boss-name">Frostbite</span>
        <span class="boss-desc">Explosive stars</span>
      </button>
      <button data-boss="2" data-desc="Thick, glowing lasers that flash on/off">
        <span class="boss-name">Electro Warden</span>
        <span class="boss-desc">Disco lasers</span>
      </button>
      <button data-boss="3" data-desc="Goes invisible, flashes then fires in a + pattern">
        <span class="boss-name">Shadow Reaver</span>
        <span class="boss-desc">Invisibility & flash</span>
      </button>
      <button data-boss="4" data-desc="Giant rainbow bullet circle with varied sizes">
        <span class="boss-name">Celestial Nova</span>
        <span class="boss-desc">Rainbow barrage</span>
      </button>
      <button data-boss="5" data-desc="Extra HP; fires a massive half‑hemisphere bullet">
        <span class="boss-name">Ironclad</span>
        <span class="boss-desc">Massive shot</span>
      </button>
      <button data-boss="6" data-desc="Poison bullets that cancel your bullets">
        <span class="boss-name">Venom Viper</span>
        <span class="boss-desc">Poison & counter</span>
      </button>
      <button data-boss="7" data-desc="Bouncy bullets with periodic dangerous lightning">
        <span class="boss-name">Stormbringer</span>
        <span class="boss-desc">Lightning & bounce</span>
      </button>
      <button data-boss="8" data-desc="Faster reload; fires in a 200° arc; bullets grow over time">
        <span class="boss-name">Blaze Fury</span>
        <span class="boss-desc">Wide, growing burst</span>
      </button>
      <button data-boss="9" data-desc="Teleports randomly; fires a shotgun burst">
        <span class="boss-name">Abyssal Oracle</span>
        <span class="boss-desc">Teleport & shotgun</span>
      </button>
      <button data-boss="10" data-desc="Random speeds; flashes rainbow; sine-moving bullets">
        <span class="boss-name">Chrono Shifter</span>
        <span class="boss-desc">Rainbow chaos</span>
      </button>
      <button data-boss="11" data-desc="Chases you fast; knockback on hit; fires homing impact shots">
        <span class="boss-name">Smasher</span>
        <span class="boss-desc">Aggressive chase</span>
      </button>
      <button data-boss="12" data-desc="Shoots one MASSIVE, slow-moving bullet">
        <span class="boss-name">Arcane Titan</span>
        <span class="boss-desc">Huge projectile</span>
      </button>
      <button data-boss="13" data-desc="Huge & slow; fires rapid small homing bullets">
        <span class="boss-name">Lunar Empress</span>
        <span class="boss-desc">Rapid homing</span>
      </button>
      <button data-boss="14" data-desc="Sun-like bullets with a damaging aura">
        <span class="boss-name">Solar Sentinel</span>
        <span class="boss-desc">Solar aura</span>
      </button>
      <button data-boss="15" data-desc="Spawns mini drones that chase & shoot">
        <span class="boss-name">Drone Commander</span>
        <span class="boss-desc">Mini drones</span>
      </button>
      <button data-boss="16" data-desc="Bullets with gravitational pull and repulsion">
        <span class="boss-name">Gravity Harbinger</span>
        <span class="boss-desc">Gravity control</span>
      </button>
      <button data-boss="17" data-desc="Chaotic 40° spread in a tangent pattern">
        <span class="boss-name">Plasma Overlord</span>
        <span class="boss-desc">Tangent chaos</span>
      </button>
      <button data-boss="18" data-desc="Drops mines with a large glowing aura">
        <span class="boss-name">Biohazard</span>
        <span class="boss-desc">Glowing mines</span>
      </button>
      <button data-boss="19" data-desc="Very fast; slows your bullets; resets arena position">
        <span class="boss-name">Time Warden</span>
        <span class="boss-desc">Temporal trickery</span>
      </button>
      <button data-boss="20" data-desc="Segmented worm firing a liquid-like stream from its head">
        <span class="boss-name">Nebula Serpent</span>
        <span class="boss-desc">Wiggly & liquid</span>
      </button>
      <button data-boss="21" data-desc="Spawns mines randomly; fires rapidly but weakly">
        <span class="boss-name">Cosmic Howler</span>
        <span class="boss-desc">Random mines</span>
      </button>
      <button data-boss="22" data-desc="Occasionally spawns an insta-kill dot behind it">
        <span class="boss-name">Void Reaper</span>
        <span class="boss-desc">Deadly dot</span>
      </button>
      <button data-boss="23" data-desc="Predictive shots based on future player movement">
        <span class="boss-name">Galactic Scorcher</span>
        <span class="boss-desc">Predictive fire</span>
      </button>
      <button data-boss="24" data-desc="Lays mines that pull in/destroy your bullets; double shotgun burst">
        <span class="boss-name">Star Eater</span>
        <span class="boss-desc">Sucking mines</span>
      </button>
      <button data-boss="25" data-desc="Semi-transparent; ultra-fast reload; weaker bullets">
        <span class="boss-name">Quasar Phantom</span>
        <span class="boss-desc">Phantom fury</span>
      </button>
      <button data-boss="26" data-desc="Shotgun extra-large bullets that explode into fragments">
        <span class="boss-name">Meteor Menace</span>
        <span class="boss-desc">Explosive shotgun</span>
      </button>
      <button data-boss="27" data-desc="Sucks you in and chases; shooting it knocks it back">
        <span class="boss-name">Black Hole Baron</span>
        <span class="boss-desc">Suction chase</span>
      </button>
      <button data-boss="28" data-desc="Every 10 sec launches a super bomb clearing your mines/bullets">
        <span class="boss-name">Supernova Spirit</span>
        <span class="boss-desc">Clearing bomb</span>
      </button>
      <button data-boss="29" data-desc="Shotgun bullets with a pulsing, damaging aura">
        <span class="boss-name">Aurora Wraith</span>
        <span class="boss-desc">Pulsing shotgun</span>
      </button>
      <button data-boss="30" data-desc="Giant bullets explode into chain fragments">
        <span class="boss-name">Comet Crusher</span>
        <span class="boss-desc">Explosive chain</span>
      </button>
      <button data-boss="31" data-desc="Fires homing missiles that bounce and explode">
        <span class="boss-name">Stellar Crusader</span>
        <span class="boss-desc">Homing missiles</span>
      </button>
      <button data-boss="32" data-desc="Shoots orbiting bullets that break off to chase you">
        <span class="boss-name">Orbiting Oracle</span>
        <span class="boss-desc">Orbit then chase</span>
      </button>
      <button data-boss="33" data-desc="Interstellar Marauder – the most stylish boss">
        <span class="boss-name">Interstellar Marauder</span>
        <span class="boss-desc">The ultimate boss</span>
      </button>
      <button data-boss="34" data-desc="Duplicates itself every 10 sec; clone fires homing bombs">
        <span class="boss-name">Celestial Conqueror</span>
        <span class="boss-desc">Duplicate mayhem</span>
      </button>
      <button data-boss="35" data-desc="All-in-one giant boss; hardest but fires rarely">
        <span class="boss-name">Apocalypse</span>
        <span class="boss-desc">Ultimate challenge</span>
      </button>
      <button data-boss="36" data-desc="Mace Smasher – swings a mace and fires small projectiles">
        <span class="boss-name">Mace Smasher</span>
        <span class="boss-desc">Swinging mace</span>
      </button>
      <button data-boss="37" data-desc="Chaos – spawns all bosses (except Apocalypse) and enlarges arena">
        <span class="boss-name">Chaos</span>
        <span class="boss-desc">Multi-boss mayhem</span>
      </button>
    </div>
    <div id="all-bosses-container">
      <button id="playAll">Play All Bosses</button>
    </div>
    <button id="retry" style="display:none;">Retry</button>
    <p>[Hold left mouse or press SPACE to fire • Press M to drop a mine]</p>
  </div>
  
  <!-- Ship Selection Overlay -->
  <div id="ship-menu">
    <h2>Select Your Ship</h2>
    <div id="ship-list">
      <!-- Ships are populated dynamically -->
    </div>
    <button id="close-ship-menu">Close</button>
  </div>

  <canvas id="gameCanvas"></canvas>

  <script>
    /***** Canvas & Global Setup *****/
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    let gameState = "menu";  // "menu", "playing", "gameover"
    let currentBossIndex = 0;
    let lastTime = 0;
    let keys = {};
    let mouse = { x: canvas.width / 2, y: canvas.height / 2 };
    let isFiring = false;
    
    // Arena boundaries.
    const FLOOR_Y = canvas.height - 100;
    let arena = { left: -2000, right: 2000, top: -500, bottom: FLOOR_Y };

    /***** Player Object *****/
    const player = {
      x: canvas.width / 2,
      y: FLOOR_Y / 2,
      vx: 0, vy: 0,
      hitbox: 12,
      health: 100,
      maxHealth: 100,
      bullets: [],
      mines: [],
      shootCooldown: 0,
      mineCooldown: 0,
      hitCooldown: 0,
      flashTimer: 0,
      weaponBonus: null,
      bonusTimer: 0,
      shieldTimer: 0,   
      speedBonusTimer: 0,
      ship: 0  // index of currently selected ship
    };

    // Buffs based on ship selection; each boss unlock gives a unique buff.
    const shipBuffs = {
      0: { fireRate: -2, bulletScale: 1.2 },
      1: { healthBonus: 20 },
      2: { bulletSpeed: 1.3 },
      3: { shieldDuration: 120 },
      4: { spreadBonus: 2 },
      5: { damageBonus: 1.4 },
      6: { speedBonus: 0.2 },
      7: { fireRate: -3 },
      8: { bulletScale: 1.5 },
      9: { healthBonus: 30 },
      // … add for each boss id as needed
    };

    const BASE_ACCELERATION = 0.3;
    const ACCELERATION = () => player.speedBonusTimer > 0 ? BASE_ACCELERATION * 1.5 : BASE_ACCELERATION;
    const BASE_FRICTION = 0.95;
    const FRICTION = () => player.speedBonusTimer > 0 ? BASE_FRICTION * 0.97 : BASE_FRICTION;

    /***** Parallax Star Background *****/
    const parallaxLayers = [];
    const layersCount = 3;
    const starsPerLayer = 180;
    for (let l = 0; l < layersCount; l++) {
      let layer = [];
      for (let i = 0; i < starsPerLayer; i++) {
        layer.push({
          x: Math.random() * canvas.width * 3 - canvas.width,
          y: Math.random() * canvas.height * 3 - canvas.height,
          radius: Math.random() * 1.8 + 0.5,
          alpha: Math.random() * 0.8 + 0.2
        });
      }
      parallaxLayers.push(layer);
    }

    /***** Powerup System *****/
    let bonus = null;
    let bonusIntervalTimer = 0;

    /***** Boss Names & Global Mode *****/
    const bossNames = [
      "Magma Maw", "Frostbite", "Electro Warden", "Shadow Reaver", "Celestial Nova",
      "Ironclad", "Venom Viper", "Stormbringer", "Blaze Fury", "Abyssal Oracle",
      "Chrono Shifter", "Smasher", "Arcane Titan", "Lunar Empress", "Solar Sentinel",
      "Drone Commander", "Gravity Harbinger", "Plasma Overlord", "Biohazard", "Time Warden",
      "Nebula Serpent", "Cosmic Howler", "Void Reaper", "Galactic Scorcher", "Star Eater",
      "Quasar Phantom", "Meteor Menace", "Black Hole Baron", "Supernova Spirit", "Aurora Wraith",
      "Comet Crusher", "Stellar Crusader", "Orbiting Oracle", "Interstellar Marauder", "Celestial Conqueror",
      "Apocalypse", "Mace Smasher", "Chaos"
    ];
    
    let allBossesMode = false;
    
    /***** Boss Class with Enhanced Behaviors *****/
    class Boss {
      constructor(index) {
        this.index = index;
        this.name = bossNames[index] || "Nameless";
        this.radius = 50 + (index % 5) * 5;
        this.hitbox = this.radius;
        this.health = 250 + index * 25;
        this.maxHealth = this.health;
        this.attackTimer = 0;
        this.movementType = index % 3;
        this.movementSpeed = (index === 36 || index === 37 ? 0.06 : 0.02 + (index % 4) * 0.005);
        this.bullets = [];
        this.drones = [];
        this.x = canvas.width / 2;
        this.y = FLOOR_Y - 250;
        this.rage = false;
        this.flashTimer = 0;
        if(index === 36) {
          this.mace = { angle: 0, length: this.radius + 50, damage: 35 };
        }
        if(index === 37) {
          this.chaosSpawned = false;
        }
      }
    
      update(playerX, playerY) {
        this.attackTimer++;
        this.rage = this.health < this.maxHealth * 0.3;
        if(this.flashTimer > 0) this.flashTimer--;
        if(this.index === 11 && this.invisibleTimer > 0) {
          this.invisibleTimer--;
        }
        
        let speed = this.movementSpeed * (this.rage ? 1.8 : 1);
        if(this.index === 36 || this.index === 37) {
          let angle = Math.atan2(playerY - this.y, playerX - this.x);
          this.x += Math.cos(angle) * speed * 20;
          this.y += Math.sin(angle) * speed * 20;
          if(this.index === 36) this.mace.angle += 0.1;
        } else {
          if (this.movementType === 0) {
            let targetX = playerX + (Math.random()-0.5)*120;
            let targetY = playerY - 180;
            this.x += (targetX - this.x) * speed;
            this.y += (targetY - this.y) * speed;
          } else if (this.movementType === 1) {
            this.x += Math.sin(this.attackTimer/40) * (3 * (this.rage ? 1.8 : 1));
            let targetY = playerY - 180;
            this.y += (targetY - this.y) * (this.movementSpeed/2);
          } else {
            this.y += Math.sin(this.attackTimer/90) * (3 * (this.rage ? 1.8 : 1));
            let targetX = playerX;
            this.x += (targetX - this.x) * (this.movementSpeed/2);
          }
          if(this.x - this.radius < arena.left) this.x = arena.left + this.radius;
          if(this.x + this.radius > arena.right) this.x = arena.right - this.radius;
          if(this.y - this.radius < arena.top) this.y = arena.top + this.radius;
          if(this.y + this.radius > arena.bottom) this.y = arena.bottom - this.radius;
        }
    
        // Update bullets.
        for (let i = this.bullets.length - 1; i >= 0; i--){
          let b = this.bullets[i];
          b.x += b.vx;
          b.y += b.vy;
          if(b.type === "sine" || b.type === "liquid") {
            b.phase = (b.phase || 0) + 0.3;
            b.y += Math.sin(b.phase) * 2.5;
          }
          if(b.grow || b.type === "massive") {
            b.radius = (b.radius || 6) + 0.08;
          }
          if(b.bounce){
            if(b.x < arena.left || b.x > arena.right) b.vx *= -1;
            if(b.y < arena.top || b.y > arena.bottom) b.vy *= -1;
          }
          if(!b.bounce && (b.x < arena.left || b.x > arena.right || b.y < arena.top || b.y > arena.bottom)){
            this.bullets.splice(i, 1);
          }
          if(b.timer !== undefined) {
            b.timer--;
            if(b.timer <= 0) {
              if(b.type === "star") {
                this.bullets.push({
                  x: b.x, y: b.y,
                  vx: 0, vy: 0,
                  color: "rgba(100,200,255,0.5)",
                  bounce: false,
                  damage: 20,
                  type: "starExplosion",
                  slowArea: true,
                  radius: 50
                });
              }
              if(b.type === "bioMine") {
                this.bullets.push({
                  x: b.x, y: b.y,
                  vx: 0, vy: 0,
                  color: "lime",
                  bounce: false,
                  damage: 35,
                  type: "mineExplosion",
                  auraRadius: 50
                });
              }
              this.bullets.splice(i, 1);
            }
          }
          if(b.explodeChain && b.hit) {
            for(let j = 0; j < 10; j++){
              this.bullets.push({
                x: b.x, y: b.y,
                vx: (Math.random()-0.5)*8,
                vy: (Math.random()-0.5)*8,
                color: "#ff9900",
                bounce: false,
                damage: 10,
                type: "chainFragment",
                radius: 4
              });
            }
            this.bullets.splice(i, 1);
          }
        }
    
        // Drone behavior for Drone Commander.
        if(this.index === 15){
          if(this.drones.length < 3){
            for(let i = 0; i < 3; i++){
              this.drones.push({ x: this.x, y: this.y, hp: 20, cooldown: 30 });
            }
          }
          this.drones.forEach(drone => {
            let angle = Math.atan2(playerY - drone.y, playerX - drone.x);
            drone.x += Math.cos(angle) * 2.5;
            drone.y += Math.sin(angle) * 2.5;
            if(drone.cooldown > 0) drone.cooldown--;
            else {
              this.bullets.push({
                x: drone.x,
                y: drone.y,
                vx: Math.cos(angle)*8,
                vy: Math.sin(angle)*8,
                color: "#00ffcc",
                bounce: false,
                damage: 10,
                type: "droneBullet",
                bulletScale: 1.0
              });
              drone.cooldown = 60;
            }
          });
          this.drones = this.drones.filter(d => distance(d.x,d.y,this.x,this.y) < 400);
        }
    
        if(this.attackTimer % 90 === 0) {
          this.fireAttack( this.rage ? 1.5 : 1 );
        }
      }
    
      fireAttack(multiplier) {
        if(this.rage) this.flashTimer = 18;
        switch(this.index) {
          case 0: { // Magma Maw
              let center = Math.atan2(player.y - this.y, player.x - this.x);
              let spread = 15 * Math.PI/180;
              for(let i = 0; i < 8; i++){
                let angle = center - spread/2 + Math.random() * spread;
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.cos(angle)*3 * multiplier,
                  vy: Math.sin(angle)*3 * multiplier,
                  color: "orangered",
                  bounce: false,
                  damage: 20 * multiplier,
                  type: "massive",
                  radius: 12 + (multiplier*0.5),
                  bulletScale: 1.4
                });
              }
            } break;
          case 1: { // Frostbite
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              for(let i=0; i<5; i++){
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.cos(angle + (Math.random()-0.5)*0.2) * 6 * multiplier,
                  vy: Math.sin(angle + (Math.random()-0.5)*0.2) * 6 * multiplier,
                  color: "cyan",
                  bounce: false,
                  damage: 0,
                  type: "star",
                  timer: 60,
                  radius: 8 + Math.random()*4,
                  bulletScale: 1.2
                });
              }
            } break;
          case 2: { // Electro Warden
              if(Math.random() < 0.7){
                let angle = Math.atan2(player.y - this.y, player.x - this.x);
                for(let i = 0; i < 4; i++){
                  let offset = (i-1.5)*0.05;
                  this.bullets.push({
                    x: this.x, y: this.y,
                    vx: Math.cos(angle+offset)*10 * multiplier,
                    vy: Math.sin(angle+offset)*10 * multiplier,
                    color: "#ffff77",
                    bounce: false,
                    damage: 15 * multiplier,
                    type: "laser",
                    thickness: 12,
                    radius: 10 + multiplier,
                    bulletScale: 1.3
                  });
                }
              }
            } break;
          case 3: { // Shadow Reaver
              this.invisibleTimer = 300;
              setTimeout(() => { this.flashTimer = 18; }, 300);
              let angles = [0, Math.PI/2, Math.PI, 3*Math.PI/2];
              angles.forEach(angle=>{
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.cos(angle)*8 * multiplier,
                  vy: Math.sin(angle)*8 * multiplier,
                  color: (Math.random() < 0.5) ? "#000" : "#fff",
                  bounce: false,
                  damage: 18 * multiplier,
                  type: "flash",
                  radius: 8,
                  bulletScale: 1.0
                });
              });
            } break;
          case 4: { // Celestial Nova
              let count = 20;
              for(let i = 0; i < count; i++){
                let hue = Math.floor(i*(360/count));
                let rad = Math.random() * 15 + 5;
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.cos(i*(Math.PI*2/count))*8 * multiplier,
                  vy: Math.sin(i*(Math.PI*2/count))*8 * multiplier,
                  color: `hsl(${hue},100%,70%)`,
                  bounce: false,
                  damage: 10 * multiplier,
                  type: "flash",
                  size: rad,
                  radius: rad,
                  bulletScale: 1.2
                });
              }
            } break;
          case 5: { // Ironclad
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              this.bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle)*5 * multiplier,
                vy: Math.sin(angle)*5 * multiplier,
                color: "#c0c0c0",
                bounce: false,
                damage: 50 * multiplier,
                type: "huge",
                radius: this.radius * 1.5,
                bulletScale: 1.5
              });
            } break;
          case 6: { // Venom Viper
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              for(let i = 0; i < 6; i++){
                let spread = (Math.random()-0.5)*0.3;
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.cos(angle+spread)*9 * multiplier,
                  vy: Math.sin(angle+spread)*9 * multiplier,
                  color: "#88ff88",
                  bounce: false,
                  damage: 16 * multiplier,
                  type: "poison",
                  poison: true,
                  destroyPlayerBullet: true,
                  radius: 8,
                  bulletScale: 1.1
                });
              }
            } break;
          case 7: { // Stormbringer
              for(let i = 0; i < 10; i++){
                let angle = i * (Math.PI*2/10);
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.cos(angle)*6 * multiplier,
                  vy: Math.sin(angle)*6 * multiplier,
                  color: "#ccddff",
                  bounce: true,
                  damage: 12 * multiplier,
                  type: "bouncy",
                  radius: 7 + Math.random()*3,
                  bulletScale: 1.0
                });
              }
              if(this.lightningTimer === undefined) this.lightningTimer = 1500;
              this.lightningTimer--;
              if(this.lightningTimer <= 0){
                let angle = Math.random()*Math.PI*2;
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.cos(angle)*14,
                  vy: Math.sin(angle)*14,
                  color: "#ffff00",
                  bounce: false,
                  damage: 40,
                  type: "lightning",
                  glow: true,
                  thickness: 14,
                  bulletScale: 1.2
                });
                this.lightningTimer = 1500;
              }
            } break;
          case 8: { // Blaze Fury
              let arc = 200 * Math.PI/180;
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              let start = angle - arc/2;
              let shots = 15;
              for(let i = 0; i < shots; i++){
                let a = start + (arc/(shots-1))*i;
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.cos(a)*8 * multiplier,
                  vy: Math.sin(a)*8 * multiplier,
                  color: "red",
                  bounce: false,
                  damage: 14 * multiplier,
                  type: "growing",
                  radius: 6 + i*0.2,
                  grow: true,
                  bulletScale: 1.3
                });
              }
            } break;
          case 9: { // Abyssal Oracle
              this.x += (Math.random()-0.5)*200;
              this.y += (Math.random()-0.5)*200;
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              for(let i = 0; i < 8; i++){
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.cos(angle+(Math.random()-0.5)*0.4)*10 * multiplier,
                  vy: Math.sin(angle+(Math.random()-0.5)*0.4)*10 * multiplier,
                  color: "purple",
                  bounce: false,
                  damage: 20 * multiplier,
                  type: "shotgun",
                  radius: 7 + Math.random()*2,
                  bulletScale: 1.0
                });
              }
            } break;
          case 10: { // Chrono Shifter
              let baseSpeed = 4 + Math.random()*4;
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              let turns = 12;
              for(let i = 0; i < turns; i++){
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.cos(angle + Math.sin(Date.now()/300 + i))*baseSpeed * multiplier,
                  vy: Math.sin(angle + Math.sin(Date.now()/300 + i))*baseSpeed * multiplier,
                  color: `hsl(${(Date.now()/10)%360},100%,70%)`,
                  bounce: false,
                  damage: 12 * multiplier,
                  type: "sine",
                  radius: 6,
                  bulletScale: 1.1
                });
              }
            } break;
          case 11: { // Smasher
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              // Fire homing impact shot.
              this.bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle)*12,
                vy: Math.sin(angle)*12,
                color: "#444",
                bounce: false,
                damage: 20 * multiplier,
                type: "homingMissile",
                homing: true,
                radius: 8,
                bulletScale: 1.3
              });
            } break;
          case 12: { // Arcane Titan
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              this.bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle)*2 * multiplier,
                vy: Math.sin(angle)*2 * multiplier,
                color: "#ffaaee",
                bounce: false,
                damage: 30 * multiplier,
                type: "massive",
                radius: this.radius * 2,
                bulletScale: 1.5
              });
            } break;
          case 13: { // Lunar Empress
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              for(let i = 0; i < 12; i++){
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.cos(angle+(i-6)*0.03)*10 * multiplier,
                  vy: Math.sin(angle+(i-6)*0.03)*10 * multiplier,
                  color: "#cccccc",
                  bounce: false,
                  damage: 8 * multiplier,
                  type: "homing",
                  homing: true,
                  radius: 6,
                  bulletScale: 1.2
                });
              }
            } break;
          case 14: { // Solar Sentinel
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              for(let i = -1; i <= 1; i++){
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.cos(angle + i*0.1)*9 * multiplier,
                  vy: Math.sin(angle + i*0.1)*9 * multiplier,
                  color: "gold",
                  bounce: false,
                  damage: 18 * multiplier,
                  type: "sun",
                  auraRadius: 30,
                  bulletScale: 1.3
                });
              }
            } break;
          case 15: { // Drone Commander
              if(this.drones.length < 3) {
                for(let i = 0; i < 3; i++){
                  this.drones.push({ x: this.x, y: this.y, hp: 20, cooldown: 30 });
                }
              }
              this.drones.forEach(drone => {
                let angle = Math.atan2(player.y - drone.y, player.x - drone.x);
                drone.x += Math.cos(angle) * 2;
                drone.y += Math.sin(angle) * 2;
                if(drone.cooldown > 0) drone.cooldown--;
                else {
                  this.bullets.push({
                    x: drone.x,
                    y: drone.y,
                    vx: Math.cos(angle)*8,
                    vy: Math.sin(angle)*8,
                    color: "#00ffcc",
                    bounce: false,
                    damage: 10,
                    type: "droneBullet",
                    radius: 6,
                    bulletScale: 1.0
                  });
                  drone.cooldown = 60;
                }
              });
              this.drones = this.drones.filter(d => distance(d.x, d.y, this.x, this.y) < 400);
            } break;
          case 16: { // gravity harbringer
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              this.bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle)*7 * multiplier,
                vy: Math.sin(angle)*7 * multiplier,
                color: "#aaffff",
                bounce: true,
                damage: 2 * multiplier,
                type: "grow",
                radius: 200,
                bulletScale: 3
              });
            } break;
          case 17: { // Plasma Overlord
              let arc = 40 * Math.PI/180;
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              let shots = 6;
              for(let i = 0; i < shots; i++){
                let a = angle - arc/2 + (arc/(shots-1))*i;
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.tan(a)*9 * multiplier,
                  vy: Math.sin(a)*9 * multiplier,
                  color: "#ff66aa",
                  bounce: false,
                  damage: 18 * multiplier,
                  type: "tangent",
                  radius: 7,
                  bulletScale: 1.2
                });
              }
            } break;
          case 18: { // Biohazard
              this.bullets.push({
                x: this.x, y: this.y,
                vx: 0, vy: 0,
                color: "lime",
                bounce: false,
                damage: 0,
                type: "bioMine",
                auraRadius: 50,
                timer: 300,
                radius: 10,
                bulletScale: 1.1
              });
            } break;
          case 19: { // Time Warden
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              this.bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(Math.random()*Math.PI*2)*6 * multiplier,
                vy: Math.sin(Math.random()*Math.PI*2)*6 * multiplier,
                color: "#cc99ff",
                bounce: false,
                damage: 14 * multiplier,
                type: "time",
                radius: 7,
                bulletScale: 1.0
              });
            } break;
          case 20: { // Nebula Serpent
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              this.bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle)*8 * multiplier,
                vy: Math.sin(angle)*8 * multiplier,
                color: "#66ff66",
                bounce: false,
                damage: 14 * multiplier,
                type: "liquid",
                radius: 8,
                bulletScale: 1.1
              });
            } break;
          case 21: { // Cosmic Howler
              if(Math.random() < 0.3){
                this.bullets.push({
                  x: arena.left + Math.random()*(arena.right-arena.left),
                  y: arena.top + Math.random()*(arena.bottom-arena.top),
                  vx: 0, vy: 0,
                  color: "#00ffff",
                  bounce: false,
                  damage: 0,
                  type: "howlerMine",
                  auraRadius: 20,
                  radius: 10,
                  bulletScale: 1.0
                });
              }
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              this.bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle)*12,
                vy: Math.sin(angle)*12,
                color: "#00ffff",
                bounce: false,
                damage: 8,
                type: "rapid",
                radius: 7,
                bulletScale: 1.0
              });
            } break;
          case 22: { // Void Reaper
              if(Math.random() < 0.5){
                let angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.cos(angle)*8 * multiplier,
                  vy: Math.sin(angle)*8 * multiplier,
                  color: "#67",
                  bounce: false,
                  damage: 180 * multiplier,
                  type: "homing",
                  homing: true,
                  radius: 5,
                  bulletScale: 1.2
                });
              }
              if(this.deadlyDotTimer === undefined) this.deadlyDotTimer = 420;
              this.deadlyDotTimer--;
              if(this.deadlyDotTimer <= 0){
                this.bullets.push({
                  x: this.x - 30, y: this.y - 30,
                  vx: 0, vy: 0,
                  color: "#000",
                  bounce: false,
                  damage: 9999,
                  type: "deadlyDot",
                  radius: 20,
                  bulletScale: 1.3
                });
                this.deadlyDotTimer = 420;
              }
            } break;
          case 23: { // Galactic Scorcher
              let futureX = player.x + player.vx*15;
              let futureY = player.y + player.vy*15;
              let angle = Math.atan2(futureY - this.y, futureX - this.x);
              this.bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle)*10 * multiplier,
                vy: Math.sin(angle)*10 * multiplier,
                color: "orangered",
                bounce: false,
                damage: 20 * multiplier,
                type: "predictive",
                radius: 8,
                bulletScale: 1.2
              });
            } break;
          case 24: { // Star Eater
              if(Math.random() < 0.4){
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: 0, vy: 0,
                  color: "#999",
                  bounce: false,
                  damage: 0,
                  type: "suckingMine",
                  pull: true,
                  auraRadius: 40,
                  radius: 10,
                  bulletScale: 1.1
                });
              }
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              for(let i = -1; i <= 1; i += 2){
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.cos(angle+i*0.1)*10 * multiplier,
                  vy: Math.sin(angle+i*0.1)*10 * multiplier,
                  color: "#ff44aa",
                  bounce: false,
                  damage: 15 * multiplier,
                  type: "shotgun",
                  radius: 8,
                  bulletScale: 1.2
                });
              }
            } break;
          case 25: { // Quasar Phantom
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              for(let i = 0; i < 20; i++){
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.cos(angle + (Math.random()-0.5)*0.3)*11 * multiplier,
                  vy: Math.sin(angle + (Math.random()-0.5)*0.3)*11 * multiplier,
                  color: "rgba(255,0,255,0.5)",
                  bounce: false,
                  damage: 8 * multiplier,
                  type: "transparent",
                  radius: 6,
                  bulletScale: 1.0
                });
              }
            } break;
          case 26: { // Meteor Menace
              let angle = Math.atan2(player.y - this.y, player.x - this.y);
              this.bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle)*7 * multiplier,
                vy: Math.sin(angle)*7 * multiplier,
                color: "#aa5500",
                bounce: true,
                damage: 30 * multiplier,
                type: "ramming",
                radius: 12,
                explodeOnHit: true,
                bulletScale: 1.3
              });
            } break;
          case 27: { // Black Hole Baron
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              this.bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle)*5 * multiplier,
                vy: Math.sin(angle)*5 * multiplier,
                color: "#444",
                bounce: false,
                damage: 18 * multiplier,
                type: "suction",
                radius: 10,
                bulletScale: 1.2
              });
              // The pulling force will be applied in the update loop (see below).
            } break;
          case 28: { // Supernova Spirit
              if(this.superBombTimer === undefined) this.superBombTimer = 600;
              this.superBombTimer--;
              if(this.superBombTimer <= 0) {
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: 0, vy: 0,
                  color: "#ffdd00",
                  bounce: false,
                  damage: 30,
                  type: "superBomb",
                  radius: 40,
                  clearBullets: true,
                  bulletScale: 1.3
                });
                this.superBombTimer = 600;
              }
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              this.bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle)*8 * multiplier,
                vy: Math.sin(angle)*8 * multiplier,
                color: "gold",
                bounce: false,
                damage: 18 * multiplier,
                type: "standard",
                radius: 8,
                bulletScale: 1.2
              });
            } break;
          case 29: { // Aurora Wraith
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              for(let i = -2; i <= 2; i++){
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.cos(angle+i*0.08)*9 * multiplier,
                  vy: Math.sin(angle+i*0.08)*9 * multiplier,
                  color: "#88ff00",
                  bounce: false,
                  damage: 14 * multiplier,
                  type: "aura",
                  auraPulse: true,
                  radius: 8,
                  bulletScale: 1.2
                });
              }
            } break;
          case 30: { // Comet Crusher
              let angle = Math.atan2(player.y - this.y, player.x - this.y);
              let giant = {
                x: this.x, y: this.y,
                vx: Math.cos(angle)*6 * multiplier,
                vy: Math.sin(angle)*5 * multiplier,
                color: "#ff8800",
                bounce: false,
                damage: 40,
                type: "giant",
                radius: 20,
                explodeChain: true,
                bulletScale: 1.4
              };
              this.bullets.push(giant);
            } break;
          case 31: { // Stellar Crusader
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              let missile = {
                x: this.x, y: this.y,
                vx: Math.cos(angle)*7 * multiplier,
                vy: Math.sin(angle)*7 * multiplier,
                color: "#99ccff",
                bounce: true,
                damage: 25 * multiplier,
                type: "homingMissile",
                homing: true,
                explosionRadius: 30,
                radius: 10,
                bulletScale: 1.5
              };
              this.bullets.push(missile);
            } break;
          case 32: { // Orbiting Oracle
              let baseAngle = Date.now() / 1000;
              for(let i = 0; i < 6; i++){
                let orbitAngle = baseAngle + i * (Math.PI*2/6);
                this.bullets.push({
                  x: this.x + Math.cos(orbitAngle)*30,
                  y: this.y + Math.sin(orbitAngle)*30,
                  vx: Math.cos(orbitAngle)*2 * multiplier,
                  vy: Math.sin(orbitAngle)*2 * multiplier,
                  color: "#ff77aa",
                  bounce: true,
                  damage: 16 * multiplier,
                  type: "orbit",
                  radius: 16,
                  bulletScale: 1.2
                });
              }
            } break;
          case 33: { // Interstellar Marauder
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              for(let i = 0; i < 10; i++){
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.cos(angle + (Math.random()-0.5)*0.3)*10 * multiplier,
                  vy: Math.sin(angle + (Math.random()-0.5)*0.3)*10 * multiplier,
                  color: `hsl(${Math.random()*360},80%,70%)`,
                  bounce: false,
                  damage: 18 * multiplier,
                  type: "marauder",
                  radius: 7,
                  bulletScale: 1.3
                });
              }
            } break;
          case 34: { // Celestial Conqueror
              if(this.cloneTimer === undefined) this.cloneTimer = 600;
              this.cloneTimer--;
              if(this.cloneTimer <= 0){
                createClone(this);
                this.cloneTimer = 600;
              }
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              this.bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle)*9 * multiplier,
                vy: Math.sin(angle)*9 * multiplier,
                color: "#cc77ff",
                bounce: false,
                damage: 20 * multiplier,
                type: "bomb",
                homing: true,
                radius: 8,
                bulletScale: 1.3
              });
            } break;
          case 35: { // Apocalypse
              if(Math.random() < 0.3){
                let angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.cos(angle)*12,
                  vy: Math.sin(angle)*12,
                  color: "red",
                  bounce: true,
                  damage: 100,
                  type: "apocalypse",
		  type: "shotgun",
                  type: "biomine",
                  type: "star",
                  radius: 10,
                  bulletScale: 1.4
                });
              }
            } break;
          case 36: { // Mace Smasher
              if(this.mace) {
                this.mace.angle += 0.1;
              }
              if(this.attackTimer % 120 === 0) {
                let angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.cos(angle)*8,
                  vy: Math.sin(angle)*8,
                  color: "#8844ff",
                  bounce: false,
                  damage: 50,
                  type: "shotgun",
                  radius: 8,
                  bulletScale: 1.2
                });
              }
            } break;
          case 37: { // Chaos
              arena = { left: arena.left*1, right: arena.right*1, top: arena.top*1, bottom: arena.bottom*1 };
              if(!this.chaosSpawned) {
                for(let id = 0; id < 36; id++){
                  spawnAdditionalBoss(id);
                }
                this.chaosSpawned = true;
              }
              for(let i = 0; i < 15; i++){
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: (Math.random()-0.5)*12,
                  vy: (Math.random()-0.5)*12,
                  color: `hsl(${Math.random()*360},100%,70%)`,
                  bounce: true,
                  damage: 20,
                  type: "chaos",
                  radius: 12,
                  bulletScale: 2
                });
              }
            } break;
          default: {
              for(let i = 0; i < 8; i++){
                let angle = i * (Math.PI * 2 / 8);
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.cos(angle)*5 * multiplier,
                  vy: Math.sin(angle)*5 * multiplier,
                  color: "#ffffff",
                  bounce: true,
                  damage: 10 * multiplier,
                  type: "grow",
                  radius: 7,
                  bulletScale: 1.1
                });
              }
            }
        }
      }
    
      drawTelegraphLine(tx, ty, color="#fff") {
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 10]);
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(tx, ty);
        ctx.stroke();
        ctx.restore();
      }
    
      draw() {
        ctx.save();
        if(this.index === 36) {
          ctx.translate(this.x, this.y);
          if(this.flashTimer > 0) {
            ctx.fillStyle = "rgba(255,255,255,0.9)";
            ctx.beginPath();
            ctx.arc(0, 0, this.radius+7, 0, Math.PI*2);
            ctx.fill();
          }
          ctx.fillStyle = "purple";
          ctx.beginPath();
          ctx.arc(0, 0, this.radius, 0, Math.PI*2);
          ctx.fill();
          if(this.mace) {
            ctx.save();
            ctx.rotate(this.mace.angle);
            ctx.strokeStyle = "#ff00ff";
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(this.radius, 0);
            ctx.lineTo(this.radius + this.mace.length, 0);
            ctx.stroke();
            ctx.restore();
          }
          ctx.restore();
        } else if(this.index === 37) {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.fillStyle = "black";
          ctx.beginPath();
          ctx.arc(0, 0, this.radius, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        } else {
          ctx.translate(this.x, this.y);
          ctx.rotate((Date.now() % 10000)/10000 * Math.PI*2);
          switch(this.index) {
            case 0: drawSpikyPolygon(0, 0, this.radius, 8, 20); break;
            case 1: drawCrystallinePolygon(0, 0, this.radius, 6); break;
            case 2: drawZigzagPolygon(0, 0, this.radius, 8); break;
            case 3: drawWavyPolygon(0, 0, this.radius, 7); break;
            case 4: drawStar(0, 0, this.radius*0.5, this.radius, 5); break;
            case 5: drawAngularPolygon(0, 0, this.radius, 6); break;
            case 6: drawSinuousShape(0, 0, this.radius, 12); break;
            case 7: drawSwirl(0, 0, this.radius, 4); break;
            case 8: drawFlameShape(0, 0, this.radius, 6); break;
            case 9: drawMysteriousShape(0, 0, this.radius, 5); break;
            case 10: drawSpiralRing(0, 0, this.radius, 3); break;
            case 11: drawGhostlyShape(0, 0, this.radius, 6); break;
            case 12: drawRunicPolygon(0, 0, this.radius, 7); break;
            case 13: drawCrescent(0, 0, this.radius); break;
            case 14: drawSunburst(0, 0, this.radius, 8); break;
            case 15: 
              drawAngularPolygon(0, 0, this.radius, 5);
              this.drones.forEach(drone => {
                ctx.save();
                ctx.fillStyle = "#00ffcc";
                ctx.beginPath();
                ctx.arc(drone.x - this.x, drone.y - this.y, 10, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();
              });
              break;
            case 16:
              ctx.fillStyle = "#aaffff";
              ctx.beginPath();
              ctx.arc(0, 0, this.radius, 0, Math.PI*2);
              ctx.fill();
              break;
            case 17:
              ctx.fillStyle = "#ff66aa";
              ctx.beginPath();
              ctx.arc(0, 0, this.radius, 0, Math.PI*2);
              ctx.fill();
              break;
            case 18:
              ctx.fillStyle = "lime";
              drawWavyPolygon(0, 0, this.radius, 6);
              break;
            case 19:
              ctx.fillStyle = "#cc99ff";
              drawSpiralRing(0, 0, this.radius, 4);
              break;
            case 20: drawSinuousShape(0, 0, this.radius, 10); break;
            case 21: drawCrystallinePolygon(0, 0, this.radius, 8); break;
            case 22: drawMysteriousShape(0, 0, this.radius, 7); break;
            case 23: drawFlameShape(0, 0, this.radius, 7); break;
            case 24: drawStar(0, 0, this.radius*0.4, this.radius, 6); break;
            case 25: drawAngularPolygon(0, 0, this.radius, 7); break;
            case 26: drawZigzagPolygon(0, 0, this.radius, 7); break;
            case 27: drawRunicPolygon(0, 0, this.radius, 8); break;
            case 28: drawSwirl(0, 0, this.radius, 5); break;
            case 29: drawCrystallinePolygon(0, 0, this.radius, 10); break;
            case 30: drawMysteriousShape(0, 0, this.radius, 6); break;
            case 31: drawStar(0, 0, this.radius*0.5, this.radius, 7); break;
            case 32: drawFlameShape(0, 0, this.radius, 8); break;
            case 33: drawWavyPolygon(0, 0, this.radius, 8); break;
            case 34: drawRunicPolygon(0, 0, this.radius, 9); break;
            case 35: 
              ctx.fillStyle = "darkred";
              ctx.beginPath();
              ctx.arc(0, 0, this.radius, 0, Math.PI*2);
              ctx.fill();
              break;
            default:
              ctx.fillStyle = "#fff";
              ctx.beginPath();
              ctx.arc(0, 0, this.radius, 0, Math.PI*2);
              ctx.fill();
          }
          if(this.rage) {
            ctx.save();
            let pulse = Math.abs(Math.sin(Date.now()/200)) * 10;
            ctx.strokeStyle = "red";
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, this.radius + pulse, 0, Math.PI*2);
            ctx.stroke();
            ctx.restore();
          }
        }
        ctx.restore();
    
        // Draw boss health bar and name.
        let barWidth = this.radius * 2;
        let barHeight = 12;
        ctx.fillStyle = "#333";
        ctx.fillRect(this.x - this.radius, this.y - this.radius - 50, barWidth, barHeight);
        ctx.fillStyle = "#f55";
        ctx.fillRect(this.x - this.radius, this.y - this.radius - 50, barWidth * (this.health / this.maxHealth), barHeight);
        ctx.strokeStyle = "#fff";
        ctx.strokeRect(this.x - this.radius, this.y - this.radius - 50, barWidth, barHeight);
        ctx.font = "16px sans-serif";
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.fillText(this.health + " / " + this.maxHealth, this.x, this.y - this.radius - 55);
        ctx.font = "18px sans-serif";
        ctx.fillText(this.name, this.x, this.y - this.radius - 70);
        ctx.strokeStyle = "rgba(255,255,255,0.3)";
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.hitbox, 0, Math.PI*2);
        ctx.stroke();
      }
    }
    
    /***** Utility Function *****/
    function distance(x1, y1, x2, y2) {
      return Math.hypot(x2 - x1, y2 - y1);
    }
    
    /***** Global Objects *****/
    let boss = null;
    
    /***** Update Loop *****/
    function update(delta) {
      document.body.className = gameState === "playing" ? "playing" : "menu-active";
    
      if(gameState === "playing"){
        if (keys["w"] || keys["ArrowUp"]) player.vy -= ACCELERATION();
        if (keys["s"] || keys["ArrowDown"]) player.vy += ACCELERATION();
        if (keys["a"] || keys["ArrowLeft"]) player.vx -= ACCELERATION();
        if (keys["d"] || keys["ArrowRight"]) player.vx += ACCELERATION();
        player.vx *= FRICTION();
        player.vy *= FRICTION();
        player.x += player.vx;
        player.y += player.vy;
    
        if(player.x - player.hitbox < arena.left){ player.x = arena.left + player.hitbox; player.vx = 0; }
        if(player.x + player.hitbox > arena.right){ player.x = arena.right - player.hitbox; player.vx = 0; }
        if(player.y - player.hitbox < arena.top){ player.y = arena.top + player.hitbox; player.vy = 0; }
        if(player.y + player.hitbox > arena.bottom){ player.y = arena.bottom - player.hitbox; player.vy = 0; }
        if(player.shootCooldown > 0) player.shootCooldown--;
        if(player.mineCooldown > 0) player.mineCooldown--;
        if(player.hitCooldown > 0) player.hitCooldown--;
        if(player.flashTimer > 0) player.flashTimer--;
        if(player.bonusTimer > 0) player.bonusTimer--;
        else player.weaponBonus = null;
        if(player.shieldTimer > 0) player.shieldTimer--;
        if(player.speedBonusTimer > 0) player.speedBonusTimer--;
    
        if((isFiring || keys[" "]) && player.shootCooldown <= 0){
          let camX = canvas.width/2 - player.x;
          let camY = canvas.height/2 - player.y;
          let worldMouseX = mouse.x - camX;
          let worldMouseY = mouse.y - camY;
          let angle = Math.atan2(worldMouseY - player.y, worldMouseX - player.x);
          let shots = 1, damageMult = 1, bulletSize = 5;
          if(player.weaponBonus === "double") shots = 2;
          if(player.weaponBonus === "triple") shots = 3;
          if(player.weaponBonus === "spread") shots = 5;
          if(player.weaponBonus === "large") { bulletSize = 8; damageMult = 1.6; }
          if(player.weaponBonus === "rapid") player.shootCooldown = 8;
          for(let i = 0; i < shots; i++){
            let spread = (shots > 1) ? (i - (shots - 1)/2)*0.1 : 0;
            player.bullets.push({
              x: player.x,
              y: player.y,
              vx: Math.cos(angle+spread) * 10,
              vy: Math.sin(angle+spread) * 10,
              size: bulletSize,
              damage: 6 * damageMult,
              type: "standard",
              radius: bulletSize,
              bulletScale: 1.0
            });
          }
          if(!player.weaponBonus || player.weaponBonus !== "rapid") player.shootCooldown = 15;
        }
    
        for(let i = player.bullets.length - 1; i >= 0; i--){
          let b = player.bullets[i];
          b.x += b.vx;
          b.y += b.vy;
          if(b.x < arena.left || b.x > arena.right || b.y < arena.top || b.y > arena.bottom){
            player.bullets.splice(i, 1);
          }
        }
    
        for(let i = player.mines.length - 1; i >= 0; i--){
          let m = player.mines[i];
          if(boss && distance(m.x, m.y, boss.x, boss.y) < boss.hitbox + 20){
            boss.health -= 35;
            boss.flashTimer = 12;
            m.exploded = true;
            m.timer = 20;
            player.mines.splice(i, 1);
            player.flashTimer = 12;
          }
        }
    
        bonusIntervalTimer++;
        if(bonusIntervalTimer > 900 && !bonus){
          let bonusTypes = ["hp", "weapon", "shield", "speed"];
          bonus = {
            x: player.x + (Math.random()-0.5)*300,
            y: player.y + (Math.random()-0.5)*300,
            type: bonusTypes[Math.floor(Math.random()*bonusTypes.length)],
            timer: 480
          };
          bonusIntervalTimer = 0;
        }
        if(bonus) bonus.timer--;
        if(bonus && bonus.timer <= 0) bonus = null;
    
        if(bonus && distance(player.x, player.y, bonus.x, bonus.y) < player.hitbox+15){
          if(bonus.type === "hp"){
            player.health = Math.min(player.maxHealth, player.health + 30);
          } else if(bonus.type === "weapon"){
            let bonusTypes = ["double", "triple", "rapid", "large", "spread"];
            player.weaponBonus = bonusTypes[Math.floor(Math.random()*bonusTypes.length)];
            player.bonusTimer = 480;
          } else if(bonus.type === "shield"){
            player.shieldTimer = 480;
          } else if(bonus.type === "speed"){
            player.speedBonusTimer = 480;
          }
          bonus = null;
        }
    
        if(boss){
          boss.update(player.x, player.y);
          boss.bullets.forEach((b, idx) => {
            let hitRadius = (b.type === "laser") ? (b.thickness || 8) : 7;
            if(distance(b.x, b.y, player.x, player.y) < player.hitbox + hitRadius){
              if(player.hitCooldown <= 0){
                let damage = b.damage || 10;
                if(player.shieldTimer > 0) damage = 0;
                player.health -= damage;
                player.hitCooldown = 60;
                player.flashTimer = 12;
              }
              boss.bullets.splice(idx, 1);
            }
          });
          if(distance(player.x, player.y, boss.x, boss.y) < player.hitbox + boss.hitbox){
            if(player.hitCooldown <= 0){
              let dmg = 25;
              if(player.shieldTimer > 0) dmg = 0;
              player.health -= dmg;
              player.hitCooldown = 60;
              player.flashTimer = 12;
            }
          }
        }
    
        if(boss){
          for(let i = player.bullets.length - 1; i >= 0; i--){
            let pb = player.bullets[i];
            if(distance(pb.x, pb.y, boss.x, boss.y) < boss.hitbox){
              boss.health -= pb.damage || 6;
              boss.flashTimer = 12;
              player.bullets.splice(i, 1);
            }
          }
        }
    
        // Apply extra effects for Black Hole Baron.
        if(boss && boss.index === 27){
          let pullForce = 0.05;
          let dx = boss.x - player.x, dy = boss.y - player.y;
          let dist = Math.hypot(dx, dy);
          if(dist < 300){
            player.vx += (dx/dist) * pullForce;
            player.vy += (dy/dist) * pullForce;
          }
        }
    
        if(player.health <= 0){
          gameState = "gameover";
          document.getElementById("retry").style.display = "inline-block";
          showMenu("Game Over! Try Again?");
        } else if(boss && boss.health <= 0){
          let btn = document.querySelector(`#boss-select button[data-boss="${currentBossIndex}"]`);
          if(btn) {
            btn.style.background = "#0a0";
            btn.innerHTML += "<br/><small>Defeated!</small>";
          }
          if(typeof unlockedShips === "undefined") unlockedShips = [];
          if(unlockedShips.indexOf(currentBossIndex) === -1) {
            unlockedShips.push(currentBossIndex);
            // Apply ship buff if selected.
            if(shipBuffs[currentBossIndex]) {
              Object.assign(player, shipBuffs[currentBossIndex]);
            }
          }
          showShipSelectionMenu();
    
          if(allBossesMode) {
            currentBossIndex++;
            if(currentBossIndex < bossNames.length) {
              setTimeout(()=>{ startGame(); }, 1000);
            } else {
              gameState = "gameover";
              document.getElementById("retry").style.display = "inline-block";
              showMenu("Congratulations! You beat all bosses!");
              allBossesMode = false;
            }
          } else {
            gameState = "gameover";
            document.getElementById("retry").style.display = "inline-block";
            showMenu("Boss Defeated! Pick Another or Retry.");
          }
        }
      }
    }
    
    /***** Draw Loop *****/
    function draw() {
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      let camX = canvas.width/2 - player.x;
      let camY = canvas.height/2 - player.y;
      parallaxLayers.forEach((layer, index) => {
        let factor = (index + 1) / layersCount;
        layer.forEach(star => {
          let sx = star.x + camX * factor;
          let sy = star.y + camY * factor;
          ctx.fillStyle = "rgba(255,255,255," + star.alpha + ")";
          ctx.beginPath();
          ctx.arc(sx, sy, star.radius, 0, Math.PI*2);
          ctx.fill();
        });
      });
    
      ctx.save();
      ctx.translate(camX, camY);
      ctx.strokeStyle = "#888";
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(arena.left, arena.top);
      ctx.lineTo(arena.left, arena.bottom);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(arena.right, arena.top);
      ctx.lineTo(arena.right, arena.bottom);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(arena.left, arena.top);
      ctx.lineTo(arena.right, arena.top);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(arena.left, arena.bottom);
      ctx.lineTo(arena.right, arena.bottom);
      ctx.stroke();
      ctx.fillStyle = "#0f0";
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.hitbox, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.3)";
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.hitbox, 0, Math.PI*2);
      ctx.stroke();
      if(player.flashTimer > 0){
        ctx.fillStyle = "rgba(255,255,255,0.5)";
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.hitbox+10, 0, Math.PI*2);
        ctx.fill();
      }
      player.bullets.forEach(b => {
        ctx.fillStyle = "#ff0";
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.size || b.radius || 5, 0, Math.PI*2);
        ctx.fill();
      });
      player.mines.forEach(m => {
        ctx.fillStyle = "#ff55ff";
        ctx.beginPath();
        ctx.arc(m.x, m.y, 10, 0, Math.PI*2);
        ctx.fill();
      });
      if(bonus){
        let bonusColor = bonus.type === "hp" ? "lime" : (bonus.type === "weapon" ? "#00f" : (bonus.type === "shield" ? "#ff0" : "orange"));
        ctx.fillStyle = bonusColor;
        ctx.beginPath();
        ctx.arc(bonus.x, bonus.y, 12, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      if(boss){
        boss.bullets.forEach(b => {
          if(b.type === "laser"){
            let grad = ctx.createLinearGradient(b.x, b.y, b.x - b.vx*0.6, b.y - b.vy*0.6);
            grad.addColorStop(0, b.color);
            grad.addColorStop(1, "rgba(255,255,255,0)");
            ctx.strokeStyle = grad;
            ctx.lineWidth = (b.thickness) ? b.thickness : 6;
            ctx.beginPath();
            ctx.moveTo(b.x, b.y);
            ctx.lineTo(b.x - b.vx*0.6, b.y - b.vy*0.6);
            ctx.stroke();
          } else {
            ctx.fillStyle = b.color;
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.radius || 6, 0, Math.PI*2);
            ctx.fill();
          }
        });
        boss.draw();
      }
      ctx.restore();
    
      drawCrosshair();
      drawUI();
    }
    
    function drawUI() {
      ctx.save();
      ctx.fillStyle = "#333";
      ctx.fillRect(20, 20, 240, 24);
      ctx.fillStyle = "#0f0";
      ctx.fillRect(20, 20, 240*(player.health/player.maxHealth), 24);
      ctx.strokeStyle = "#fff";
      ctx.strokeRect(20, 20, 240, 24);
      if(boss){
        let barWidth = 240;
        ctx.fillStyle = "#333";
        ctx.fillRect(canvas.width - barWidth - 20, 20, barWidth, 24);
        ctx.fillStyle = "#f00";
        ctx.fillRect(canvas.width - barWidth - 20, 20, barWidth*(boss.health/boss.maxHealth), 24);
        ctx.strokeStyle = "#fff";
        ctx.strokeRect(canvas.width - barWidth - 20, 20, barWidth, 24);
      }
      let infoY = 70;
      ctx.font = "20px sans-serif";
      ctx.fillStyle = "#ff0";
      if(player.weaponBonus) ctx.fillText("Weapon: " + player.weaponBonus.toUpperCase(), 20, infoY);
      if(player.shieldTimer > 0) ctx.fillText("Shield Active", 20, infoY+25);
      if(player.speedBonusTimer > 0) ctx.fillText("Speed Boost", 20, infoY+50);
      ctx.restore();
    }
    
    function drawCrosshair() {
      ctx.save();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(mouse.x - 12, mouse.y);
      ctx.lineTo(mouse.x + 12, mouse.y);
      ctx.moveTo(mouse.x, mouse.y - 12);
      ctx.lineTo(mouse.x, mouse.y + 12);
      ctx.stroke();
      ctx.restore();
    }
    
    /***** Main Game Loop *****/
    function gameLoop(timestamp) {
      let delta = timestamp - lastTime;
      lastTime = timestamp;
      update(delta);
      draw();
      requestAnimationFrame(gameLoop);
    }
    
    /***** Start/Reset Game *****/
    function startGame() {
      player.x = canvas.width/2;
      player.y = FLOOR_Y/2;
      player.vx = 0;
      player.vy = 0;
      player.health = player.maxHealth;
      player.bullets = [];
      player.mines = [];
      player.hitCooldown = 0;
      player.shootCooldown = 0;
      player.mineCooldown = 0;
      player.weaponBonus = null;
      player.bonusTimer = 0;
      player.shieldTimer = 0;
      player.speedBonusTimer = 0;
      bonus = null;
      bonusIntervalTimer = 0;
      boss = new Boss(currentBossIndex);
      boss.x = canvas.width/2;
      boss.y = FLOOR_Y - 250;
      gameState = "playing";
      document.getElementById("menu").style.display = "none";
    }
    
    function showMenu(message = "") {
      gameState = "menu";
      document.getElementById("menu").style.display = "flex";
      if(message !== ""){
        document.querySelector("#menu h1").textContent = message;
      } else {
        document.querySelector("#menu h1").textContent = "Cosmic Boss Fights";
      }
    }
    
    /***** Ship Selection Menu Functions *****/
    function showShipSelectionMenu() {
      const shipList = document.getElementById("ship-list");
      shipList.innerHTML = "";
      if(typeof unlockedShips !== "undefined" && unlockedShips.length > 0) {
        unlockedShips.forEach((id) => {
          let btn = document.createElement("button");
          btn.innerHTML = `<canvas id="ship-${id}" width="100" height="100"></canvas><br/><span>Ship ${id}</span>`;
          btn.onclick = () => {
            player.ship = id;
            if(shipBuffs[id]) Object.assign(player, shipBuffs[id]);
            alert("Ship " + id + " selected with buff: " + JSON.stringify(shipBuffs[id]));
          };
          shipList.appendChild(btn);
          let shipCanvas = document.getElementById("ship-" + id);
          let shipCtx = shipCanvas.getContext("2d");
          drawShip(shipCtx, id);
        });
      } else {
        shipList.innerHTML = "<p>No ships unlocked yet.</p>";
      }
      document.getElementById("ship-menu").style.display = "flex";
    }
    
    function drawShip(ctx, id) {
      ctx.clearRect(0,0,100,100);
      ctx.save();
      ctx.translate(50,50);
      if(id % 4 === 0) {
        ctx.fillStyle = "#ff5555";
        ctx.beginPath();
        ctx.moveTo(0, -30);
        ctx.lineTo(20, 10);
        ctx.lineTo(-20, 10);
        ctx.closePath();
        ctx.fill();
      } else if(id % 4 === 1) {
        ctx.fillStyle = "#55ff55";
        ctx.beginPath();
        ctx.arc(0,0,25,0,Math.PI*2);
        ctx.fill();
      } else if(id % 4 === 2) {
        ctx.fillStyle = "#5555ff";
        ctx.beginPath();
        ctx.rect(-20,-20,40,40);
        ctx.fill();
      } else {
        ctx.fillStyle = "#ffff55";
        ctx.beginPath();
        ctx.moveTo(-30, -15);
        ctx.lineTo(30, -15);
        ctx.lineTo(0, 30);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();
    }
    
    function spawnAdditionalBoss(id) {
      if(typeof chaosBosses === "undefined") chaosBosses = [];
      let extraBoss = new Boss(id);
      extraBoss.x = Math.random() * (arena.right - arena.left) + arena.left;
      extraBoss.y = Math.random() * (arena.bottom - arena.top) + arena.top;
      chaosBosses.push(extraBoss);
    }
    
    /***** Event Listeners *****/
    window.addEventListener('keydown', (e) => {
      keys[e.key] = true;
      if(e.key === " " && gameState === "playing"){
        // Firing is handled by checking keys in update().
      }
      if(e.key.toLowerCase() === "m" && player.mineCooldown <= 0 && gameState === "playing"){
        player.mines.push({ x: player.x, y: player.y });
        player.mineCooldown = 50;
      }
    });
    window.addEventListener('keyup', (e) => { keys[e.key] = false; });
    canvas.addEventListener('mousemove', (e) => { mouse.x = e.clientX; mouse.y = e.clientY; });
    canvas.addEventListener('mousedown', (e) => { isFiring = true; });
    canvas.addEventListener('mouseup', (e) => { isFiring = false; });
    
    document.getElementById("boss-select").addEventListener('click', (e) => {
      if(e.target.tagName === "BUTTON" || e.target.parentElement.tagName === "BUTTON"){
        let btn = e.target.tagName === "BUTTON" ? e.target : e.target.parentElement;
        currentBossIndex = parseInt(btn.getAttribute("data-boss"));
        allBossesMode = false;
        document.getElementById("retry").style.display = "none";
        startGame();
      }
    });
    document.getElementById("playAll").addEventListener('click', () => {
      allBossesMode = true;
      currentBossIndex = 0;
      document.getElementById("retry").style.display = "none";
      startGame();
    });
    document.getElementById("retry").addEventListener('click', () => {
      document.getElementById("retry").style.display = "none";
      startGame();
    });
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });
    
    document.getElementById("close-ship-menu").addEventListener('click', () => {
      document.getElementById("ship-menu").style.display = "none";
    });
    
    requestAnimationFrame(gameLoop);
    
    /***** Drawing Helper Functions *****/
    function drawSpikyPolygon(x, y, radius, spikes, spikeLength) {
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      for (let i = 0; i < spikes; i++) {
        let angle = i * (Math.PI * 2 / spikes);
        ctx.lineTo(Math.cos(angle) * (radius + spikeLength), Math.sin(angle) * (radius + spikeLength));
        angle += Math.PI / spikes;
        ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
      }
      ctx.closePath();
      ctx.fillStyle = "#fff";
      ctx.fill();
      ctx.restore();
    }
    
    function drawCrystallinePolygon(x, y, radius, sides) {
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      for (let i = 0; i <= sides; i++) {
        let angle = i * 2 * Math.PI / sides;
        ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
      }
      ctx.closePath();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }
    
    function drawZigzagPolygon(x, y, radius, segments) {
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      for (let i = 0; i < segments; i++) {
        let angle = i / segments * 2 * Math.PI;
        let offset = (i % 2 === 0) ? radius : radius * 0.75;
        ctx.lineTo(Math.cos(angle) * offset, Math.sin(angle) * offset);
      }
      ctx.closePath();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }
    
    function drawWavyPolygon(x, y, radius, points) {
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      for(let i = 0; i < points; i++){
        let angle = i * (Math.PI*2/points);
        let r = radius + Math.sin(i * 3) * 7;
        ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
      }
      ctx.closePath();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }
    
    function drawStar(x, y, innerRadius, outerRadius, points) {
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      for (let i = 0; i < 2 * points; i++) {
        let r = (i % 2 === 0 ? outerRadius : innerRadius);
        let angle = i * Math.PI / points;
        ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
      }
      ctx.closePath();
      ctx.fillStyle = "#fff";
      ctx.fill();
      ctx.restore();
    }
    
    function drawAngularPolygon(x, y, radius, sides) {
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      for (let i = 0; i < sides; i++) {
        let angle = i * 2 * Math.PI / sides;
        ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
      }
      ctx.closePath();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.restore();
    }
    
    function drawSinuousShape(x, y, radius, points) {
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      for (let i = 0; i < points; i++) {
        let angle = i * 2 * Math.PI / points;
        let offset = radius + Math.sin(angle * 3) * 7;
        ctx.lineTo(Math.cos(angle) * offset, Math.sin(angle) * offset);
      }
      ctx.closePath();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }
    
    function drawSwirl(x, y, radius, turns) {
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      for (let i = 0; i < 100; i++) {
        let angle = i * (Math.PI * 2 / 100) * turns;
        let r = radius * (i / 100);
        ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
      }
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }
    
    function drawFlameShape(x, y, radius, points) {
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      for (let i = 0; i < points; i++) {
        let angle = i * 2 * Math.PI / points;
        let offset = radius + Math.random() * 7;
        ctx.lineTo(Math.cos(angle) * offset, Math.sin(angle) * offset);
      }
      ctx.closePath();
      ctx.fillStyle = "orange";
      ctx.fill();
      ctx.restore();
    }
    
    function drawMysteriousShape(x, y, radius, sides) {
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      for (let i = 0; i < sides; i++) {
        let angle = i * 2 * Math.PI / sides;
        let offset = radius + (Math.random() - 0.5) * 12;
        ctx.lineTo(Math.cos(angle) * offset, Math.sin(angle) * offset);
      }
      ctx.closePath();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }
    
    function drawGhostlyShape(x, y, radius, sides) {
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      for (let i = 0; i < sides; i++) {
        let angle = i * 2 * Math.PI / sides;
        ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
      }
      ctx.closePath();
      ctx.strokeStyle = "rgba(200,200,255,0.8)";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }
    
    function drawSpiralRing(x, y, radius, segments) {
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      for (let i = 0; i < segments; i++) {
        let angle = i * (Math.PI * 2 / segments);
        ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
      }
      ctx.closePath();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }
    
    function drawRunicPolygon(x, y, radius, sides) {
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      for (let i = 0; i < sides; i++) {
        let angle = i * 2 * Math.PI / sides;
        let offset = radius + (Math.random() - 0.5) * 7;
        ctx.lineTo(Math.cos(angle) * offset, Math.sin(angle) * offset);
      }
      ctx.closePath();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.restore();
    }
    
    function drawCrescent(x, y, radius) {
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      ctx.arc(0, 0, radius, Math.PI * 0.2, Math.PI * 1.8);
      ctx.arc(10, 0, radius, Math.PI * 1.2, Math.PI * 0.2, true);
      ctx.closePath();
      ctx.fillStyle = "#fff";
      ctx.fill();
      ctx.restore();
    }
    
    function drawSunburst(x, y, radius, rays) {
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      for (let i = 0; i < rays; i++) {
        let angle = i * 2 * Math.PI / rays;
        ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
        angle += Math.PI / rays;
        ctx.lineTo(Math.cos(angle) * (radius * 1.4), Math.sin(angle) * (radius * 1.4));
      }
      ctx.closePath();
      ctx.fillStyle = "yellow";
      ctx.fill();
      ctx.restore();
    }
  </script>
</body>
</html>
